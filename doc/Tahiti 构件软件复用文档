				Tahiti 构件软件复用文档
一、构件介绍
这一构件基于netty架构提供的异步的、事件驱动的网络应用程序和工具开发，实现了多个客户端的实时通信，完整地涵盖了通信工具的基础功能点。


二、使用说明
>JDK版本：JDK8.0
>IDE：JetBrains Intellij IDEA
>安装Protobuf：
 protoc 3.0
 protocol buffer 是在客户端和服务器进行数据交互的格式，它独立于语言，独立于平台，可以定义自己的数据结构，然后使用代码生成器生成的代码去读写这个数据结构。
 1、在.proto文件中定义需要做串行化的数据结构信息。例如
 2、定义好报文格式（message）之后，调用protobuf的编辑器protoc 将.proto文件编译成特定语言的类
 3、运用生成的类串行化或者反串行化数据。
>给maven设置环境变量
1、Menu->Tool Windows 打开maven界面
2、tahiti.protocal -> Lifecycles -> compile -> Create[tahiti.protocol] 新建profile
3、将环境变量PROTOC_PATH设置成你的protoc的安装路径
>可以使用octoteam.tahiti.protocl.SocketMessageProtos生成串行化数据。

三、接口说明
1、client端：
>HeartbeatHandler:
作用：客户端每隔30秒将接受到来自服务端的心跳信息。
方法：触发对应的Channel读取Message。

>ResponseCallbackHandler
作用：根据服务端传来的登陆结果的消息更新UI。
方法：login 的时候传入一个回调方法，这个方法是根据登陆是否成功的状态改变界面。每个人 login 的时候都会有自己的回调方法。在多人同时 login 的时候，程序会把这些方法和 每个人 的 seqid 绑定，存入callbacks 这个 map 中，一旦收到服务器返回的登陆状态消息，就调用 resolveCallback， get 出来这个方法，然后调用方法去根据登陆状态消息处理界面

>LoginResponseHandler
作用：提高程序的可扩展性。
方法：发送登陆成功事件。

>SendMessageHandler
作用：提高程序的可扩展性。
方法：客户端向服务端发送需要转发的消息的触发一个SendMessageEvent。

2、server端：
>AuthFilterHandler: 
作用：验证服务端收发消息的身份有效性
方法：messageSent：服务器有两种回应方式，被动回应直接通过；主动回应需要判断客户端用户身份的有效性，如果该用户已经登陆，则下发信息；如果该用户处于未登陆状态					，则不处理该消息。
	 messageReceived：如果不属于request类消息则直接下发到下一个handler，如果属于request则先验证合法性。

> AuthRequestHandler：
作用：处理客户端登陆消息。
方法：收到用户登陆信息，验证；如果在数据库中，返回成功登里信息；或者返回用户不存在、或者密码错误。

>HeartbeatHandler
作用：每隔30秒，向客户端发送心跳。
方法：每隔30秒接受到IdleStateHandler发来的定时事件，然后现客户端下发心跳消息。

>MessageForwardHandler
作用：1》收集所有客户端的链接。
	2》如果客户端接受CHAT_SEND_MESSAGE_REQUEST类的消息，则群发给其它所有的客户端。
方法：messageReceived负责群发消息，channelActive收集所有的客户端链接。

>MessageRequestHandler
作用：对于群发的消息，回复发起群发的客户端成功的消息。
方法：判断消息类型，如果属于CHAT_SEND_MESSAGE_REQUEST类型则回复成功。

>RequestRateLimitHandler
作用：实现了每秒钟不能超过5次，每个登陆的账号不能发超过100条的限制（具体数量可以在配置文件中修改）。
方法：构造函数：根据不同的传入参数构造相应的方法：（perSecond）一种基于时间，（perSession）一种基于session

>SessionExpireHandler
作用：提醒用户在发送超过100条之后session过期
方法：传入一个RateLimitExceededEvent类型的event，如果event.getName()为NAME_PER_SESSION，给客户端发送session过期的消息。

>UserEventHandler
作用：把所有的event都传给eventbus，根据event类型来调用不同的订阅者。
方法：该Handler处于所有pipeline的末端，将pipeline所有的event post到eventbus中。

